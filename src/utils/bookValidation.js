// Book structure validation utilities

/**
 * Canonical Book Structure
 */
export const BOOK_SCHEMA = {
  id: 'string',
  title: 'string',
  author: 'string',
  description: 'string',
  pages: [
    {
      id: 'string',
      front: {
        id: 'string',
        name: 'string',
        url: 'string',
        type: 'string',
        thumbnail: 'string'
      },
      back: null // or same structure as front
    }
  ],
  volumeMetadata: {
    pageCount: 'number',
    coverMaterial: 'string',
    pageWidth: 'number',
    pageHeight: 'number',
    pageDepth: 'number'
  },
  metadata: {
    created: 'ISO 8601 string',
    modified: 'ISO 8601 string',
    sourceType: 'freegrid | standard',
    autoGenerated: 'boolean'
  }
};

/**
 * Validate a book object against the canonical structure
 * @param {Object} bookData - The book data to validate
 * @returns {Object} { valid: boolean, errors: string[] }
 */
export function validateBookStructure(bookData) {
  const errors = [];

  // Check required top-level fields
  if (!bookData) {
    errors.push('Book data is null or undefined');
    return { valid: false, errors };
  }

  if (!bookData.id || typeof bookData.id !== 'string') {
    errors.push('Missing or invalid book ID');
  }

  if (!bookData.title || typeof bookData.title !== 'string') {
    errors.push('Missing or invalid book title');
  }

  if (!bookData.pages || !Array.isArray(bookData.pages)) {
    errors.push('Missing or invalid pages array');
  } else {
    // Validate each page
    bookData.pages.forEach((page, index) => {
      if (!page.id) {
        errors.push(`Page ${index} missing ID`);
      }
      
      // Validate front side
      if (!page.front) {
        errors.push(`Page ${index} missing front side`);
      } else if (typeof page.front === 'object' && !page.front.id) {
        errors.push(`Page ${index} front side missing media ID`);
      }
      
      // Back side is optional but must be valid if present
      if (page.back && typeof page.back === 'object' && !page.back.id) {
        errors.push(`Page ${index} back side missing media ID`);
      }
    });
  }

  // Validate volumeMetadata
  if (!bookData.volumeMetadata) {
    errors.push('Missing volumeMetadata');
  } else {
    if (typeof bookData.volumeMetadata.pageCount !== 'number') {
      errors.push('Invalid or missing pageCount in volumeMetadata');
    }
  }

  // Validate metadata
  if (!bookData.metadata) {
    errors.push('Missing metadata');
  } else {
    if (!bookData.metadata.created) {
      errors.push('Missing creation date in metadata');
    }
    if (!['freegrid', 'standard'].includes(bookData.metadata.sourceType)) {
      errors.push('Invalid sourceType in metadata');
    }
  }

  return { valid: errors.length === 0, errors };
}

/**
 * Create a canonical book object from partial data
 * @param {Object} partialData - Partial book data
 * @returns {Object} Complete book object following canonical structure
 */
export function createCanonicalBook(partialData = {}) {
  const now = new Date().toISOString();
  
  return {
    id: partialData.id || `book_${Date.now()}`,
    title: partialData.title || 'Untitled Book',
    author: partialData.author || '',
    description: partialData.description || '',
    pages: partialData.pages || [],
    volumeMetadata: {
      pageCount: partialData.volumeMetadata?.pageCount || 0,
      coverMaterial: partialData.volumeMetadata?.coverMaterial || 'hardcover',
      pageWidth: partialData.volumeMetadata?.pageWidth || 8.5,
      pageHeight: partialData.volumeMetadata?.pageHeight || 11,
      pageDepth: partialData.volumeMetadata?.pageDepth || 0.1,
      ...partialData.volumeMetadata
    },
    metadata: {
      created: partialData.metadata?.created || now,
      modified: now,
      sourceType: partialData.metadata?.sourceType || 'standard',
      autoGenerated: partialData.metadata?.autoGenerated || false,
      ...partialData.metadata
    }
  };
}

/**
 * Migrate old book format to canonical structure
 * @param {Object} oldBook - Book in old format
 * @returns {Object} Book in canonical format
 */
export function migrateBookToCanonical(oldBook) {
  // Handle old format where pages might be simple arrays
  let pages = [];
  
  if (oldBook.pages && Array.isArray(oldBook.pages)) {
    pages = oldBook.pages.map((page, index) => {
      // If page is already in new format, keep it
      if (page.id && (page.front || page.back)) {
        return page;
      }
      
      // Convert old format (assuming direct media reference)
      return {
        id: `page_${index}`,
        front: page,
        back: null
      };
    });
  }

  return createCanonicalBook({
    ...oldBook,
    pages,
    volumeMetadata: {
      ...oldBook.volumeMetadata,
      pageCount: pages.length
    }
  });
}

/**
 * Create a placeholder media object for missing items
 * @param {string} name - Name for the placeholder
 * @param {string} id - Optional ID
 * @returns {Object} Placeholder media object
 */
export function createPlaceholderMedia(name = 'Missing Media', id = null) {
  return {
    id: id || `placeholder_${Date.now()}`,
    name,
    type: 'placeholder',
    url: '',
    thumbnail: '',
    isPlaceholder: true,
    isMissing: true
  };
}